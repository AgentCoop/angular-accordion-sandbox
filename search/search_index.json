{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Angular 8 summary The goal of this project is to centralise some how-tos using angular. As this is not a technology I'm using on a daily basis, this repo, should help me to get back on track quickly. It illustrates some implementation practices used in different project, and from practices coming from http://angular.io and other web source like stackoverflow. The application is served via a simple python flask app, see this section from some explanations. Must read https://angular.io/tutorial * Installation Install last version of Angular CLI sudo npm install -g @angular/cli@latest # Add to path: export PATH = $PATH ; ~/.nvm/versions/node/v8.9.4/lib/node_modules/node/lib/node_modules/node/bin angular App Development Development server locally Run ng serve for a dev server. Navigate to http://localhost:4200/ . The app will automatically reload if you change any of the source files. Code scaffolding Run ng generate component component-name to generate a new component. You can also use ng generate directive|pipe|service|class|module . Build Angular App Run ng build to build the project. The build artifacts will be stored in the dist/ directory. Use the -prod flag for a production build. Running unit tests Run ng test --singleRun=false to execute the unit tests via Karma without stopping, so any change to the tests will run immediately. Running end-to-end tests Run ng e2e to execute the end-to-end tests via Protractor . Before running the tests make sure you are serving the app via ng serve . Python Flask Server Development The folder angularApp includes a python flask and an angular SPA. The angular SPA was created using ng new angularApp . The package.json was modified to specify the output directory when compiling typescript to js should be the static folder: \"build\": { \"builder\": \"@angular-devkit/build-angular:browser\", \"options\": { \"outputPath\": \"static\", So now any ng build compile the SPA for python Flask to serve. The flask app is angularApp.py and it render the index.html: @app.route(\"/\") def hello(): return render_template('index.html') Continuous deployment Using Git Action, the workflow (.github/workflows/dockerbuild.yaml) builds a docker image for the app. See this article on github.com to setup a workflow. The triggering event is a push to the repository. It uses the github-hosted ubuntu runner. Each job in a workflow executes in a fresh instance of the virtual environment, and steps within a job can share information using the filesystem. The workflow uses a set of secrets to connect to dockerhub and github: DOCKER_USERNAME: ${ { secrets.DOCKER_USERNAME } } DOCKER_PASSWORD: ${ { secrets.DOCKER_PASSWORD } } DOCKER_REPOSITORY: ${ { secrets.DOCKER_REPOSITORY } } DOCKER_IMAGE: ${ { secrets.DOCKER_IMAGE } } GITHUB_TOKEN: ${ { secrets.GITHUB_TOKEN } } and build the docker image and push it under the jbcodeforce user. Module and declarations The purpose of a NgModule is to declare each thing you create in Angular, and groups them together. declarations is for things you\u2019ll use in your templates: mainly components. providers is for service declarations: declarations / components are in local scope (private visibility), providers / services are (generally) in global scope (public visibility) Components are only usable in the current module. If you need to use them outside the module, line in other modules, you\u2019ll have to export them. In the module below the components are declared and also exported as they are at the application global scope. declarations: [ InputComponent, DropdownComponent, MessageErrorComponent, FileUploadComponent ], providers: [ FileUploadService, ], exports: [ InputComponent, DropdownComponent, MessageErrorComponent, FileUploadComponent ] On the contrary, services you provided will generally be available / injectable anywhere in your app, in all modules. When assessing the import of module, you need to consider: if the module is imported for components, you\u2019ll need to import it in each module needing them, if the module is imported for services, you\u2019ll need to import it only once, in the first app module. Modules to import each time you need them: common module except in the first app module, because it\u2019s already part of the BrowserModule. FormsModule / ReactiveFormsModule MatXModule and other UI modules any other module giving you components, directives or pipes Modules to import only once HttpClientModule BrowserAnimationsModule or NoopAnimationsModule any other module providing you services only. Example of login module See the note here HttpClient https://medium.com/codingthesmartway-com-blog/angular-4-3-httpclient-accessing-rest-web-services-with-angular-2305b8fd654b Attribute binding When to use <element [attribute]=\"\" versus attribute2=\"\" https://stackoverflow.com/questions/39112904/property-binding-vs-attribute-interpolation","title":"Introduction"},{"location":"#angular-8-summary","text":"The goal of this project is to centralise some how-tos using angular. As this is not a technology I'm using on a daily basis, this repo, should help me to get back on track quickly. It illustrates some implementation practices used in different project, and from practices coming from http://angular.io and other web source like stackoverflow. The application is served via a simple python flask app, see this section from some explanations.","title":"Angular 8 summary"},{"location":"#must-read","text":"https://angular.io/tutorial *","title":"Must read"},{"location":"#installation","text":"Install last version of Angular CLI sudo npm install -g @angular/cli@latest # Add to path: export PATH = $PATH ; ~/.nvm/versions/node/v8.9.4/lib/node_modules/node/lib/node_modules/node/bin","title":"Installation"},{"location":"#angular-app-development","text":"","title":"angular App Development"},{"location":"#development-server-locally","text":"Run ng serve for a dev server. Navigate to http://localhost:4200/ . The app will automatically reload if you change any of the source files.","title":"Development server locally"},{"location":"#code-scaffolding","text":"Run ng generate component component-name to generate a new component. You can also use ng generate directive|pipe|service|class|module .","title":"Code scaffolding"},{"location":"#build-angular-app","text":"Run ng build to build the project. The build artifacts will be stored in the dist/ directory. Use the -prod flag for a production build.","title":"Build Angular App"},{"location":"#running-unit-tests","text":"Run ng test --singleRun=false to execute the unit tests via Karma without stopping, so any change to the tests will run immediately.","title":"Running unit tests"},{"location":"#running-end-to-end-tests","text":"Run ng e2e to execute the end-to-end tests via Protractor . Before running the tests make sure you are serving the app via ng serve .","title":"Running end-to-end tests"},{"location":"#python-flask-server-development","text":"The folder angularApp includes a python flask and an angular SPA. The angular SPA was created using ng new angularApp . The package.json was modified to specify the output directory when compiling typescript to js should be the static folder: \"build\": { \"builder\": \"@angular-devkit/build-angular:browser\", \"options\": { \"outputPath\": \"static\", So now any ng build compile the SPA for python Flask to serve. The flask app is angularApp.py and it render the index.html: @app.route(\"/\") def hello(): return render_template('index.html')","title":"Python Flask Server Development"},{"location":"#continuous-deployment","text":"Using Git Action, the workflow (.github/workflows/dockerbuild.yaml) builds a docker image for the app. See this article on github.com to setup a workflow. The triggering event is a push to the repository. It uses the github-hosted ubuntu runner. Each job in a workflow executes in a fresh instance of the virtual environment, and steps within a job can share information using the filesystem. The workflow uses a set of secrets to connect to dockerhub and github: DOCKER_USERNAME: ${ { secrets.DOCKER_USERNAME } } DOCKER_PASSWORD: ${ { secrets.DOCKER_PASSWORD } } DOCKER_REPOSITORY: ${ { secrets.DOCKER_REPOSITORY } } DOCKER_IMAGE: ${ { secrets.DOCKER_IMAGE } } GITHUB_TOKEN: ${ { secrets.GITHUB_TOKEN } } and build the docker image and push it under the jbcodeforce user.","title":"Continuous deployment"},{"location":"#module-and-declarations","text":"The purpose of a NgModule is to declare each thing you create in Angular, and groups them together. declarations is for things you\u2019ll use in your templates: mainly components. providers is for service declarations: declarations / components are in local scope (private visibility), providers / services are (generally) in global scope (public visibility) Components are only usable in the current module. If you need to use them outside the module, line in other modules, you\u2019ll have to export them. In the module below the components are declared and also exported as they are at the application global scope. declarations: [ InputComponent, DropdownComponent, MessageErrorComponent, FileUploadComponent ], providers: [ FileUploadService, ], exports: [ InputComponent, DropdownComponent, MessageErrorComponent, FileUploadComponent ] On the contrary, services you provided will generally be available / injectable anywhere in your app, in all modules. When assessing the import of module, you need to consider: if the module is imported for components, you\u2019ll need to import it in each module needing them, if the module is imported for services, you\u2019ll need to import it only once, in the first app module. Modules to import each time you need them: common module except in the first app module, because it\u2019s already part of the BrowserModule. FormsModule / ReactiveFormsModule MatXModule and other UI modules any other module giving you components, directives or pipes Modules to import only once HttpClientModule BrowserAnimationsModule or NoopAnimationsModule any other module providing you services only.","title":"Module and declarations"},{"location":"#example-of-login-module","text":"See the note here","title":"Example of login module"},{"location":"#httpclient","text":"https://medium.com/codingthesmartway-com-blog/angular-4-3-httpclient-accessing-rest-web-services-with-angular-2305b8fd654b","title":"HttpClient"},{"location":"#attribute-binding","text":"When to use <element [attribute]=\"\" versus attribute2=\"\" https://stackoverflow.com/questions/39112904/property-binding-vs-attribute-interpolation","title":"Attribute binding"},{"location":"angularcli/","text":"Angular CLI References https://www.sitepoint.com/ultimate-angular-cli-reference/","title":"Angular CLI"},{"location":"angularcli/#angular-cli","text":"","title":"Angular CLI"},{"location":"angularcli/#references","text":"https://www.sitepoint.com/ultimate-angular-cli-reference/","title":"References"},{"location":"basic-app/","text":"Basic Application Structure In this section I address the following subject: Main page Structure Routing footer and header Main page When creating the application with ng new command, the application is ready to run immediately with ng serve . But we want to add a home page, a login page, a standard header, footer and support internal routing, to do so we need to change the app.component.html to have just the page placeholders: < div class = \"container\" style = \"position:relative;\" > < router-outlet ></ router-outlet > </ div > We need to import the angular router in the app.module, but in fact it is better to isolate the main routing in its own module, and when a feature support page navigation it will define its own routes. We need to add a home component with ng g component features/home that we will enhance later. Routing Add a routing module. with ng g module features/routing . Define a route to home in a separate file (routes.ts) so it can be imported in test module. export const routes : Routes = [ { path : 'home' , component : HomeComponent }, { path : '**' , redirectTo : '/home' , pathMatch : 'full' } ]; * Add the routing definition in the routing module and export the RouterModule. import { routes } from './routes' ; @ NgModule ({ imports : [ RouterModule . forRoot ( routes , { useHash : true , enableTracing : false }), CommonModule ], exports : [ RouterModule ], }); Add the import RoutingModule in the main app Module import { RoutingModule } from './features/routing/routing.module' ; imports : [ BrowserModule , RoutingModule ], Adding footer and header Any shared component are in shared folder. Create a shared module: ng g module shared Create footer and header components: ng g component shared/header * Add those components in the export of the shared module @ NgModule ({ imports : [ CommonModule ], declarations : [ HeaderComponent , FooterComponent ], exports : [ FooterComponent , HeaderComponent ] }) Add the SharedModule in the imports of the app module. For each component we add basic jasmine tests on element presence within the component. Map with Leaflet See tutorial here Install it with npm --save install leaflet @types/leaflet Then modify angular.json file to add new styles: \"styles\": [ \"src/styles.css\", \"./node_modules/leaflet/dist/leaflet.css\" ], * Specify in the src/tsconfig.app.json to use the typescript version of the library Leaflet. \"compilerOptions\" : { \"outDir\" : \"../out-tsc/app\" , \"baseUrl\" : \"./\" , \"module\" : \"es2015\" , \"types\" : [ \"leaflet\" ] } , In the component to integrate the map add L variable with import * as L from 'leaflet' ;","title":"Basic App"},{"location":"basic-app/#basic-application-structure","text":"In this section I address the following subject: Main page Structure Routing footer and header","title":"Basic Application Structure"},{"location":"basic-app/#main-page","text":"When creating the application with ng new command, the application is ready to run immediately with ng serve . But we want to add a home page, a login page, a standard header, footer and support internal routing, to do so we need to change the app.component.html to have just the page placeholders: < div class = \"container\" style = \"position:relative;\" > < router-outlet ></ router-outlet > </ div > We need to import the angular router in the app.module, but in fact it is better to isolate the main routing in its own module, and when a feature support page navigation it will define its own routes. We need to add a home component with ng g component features/home that we will enhance later.","title":"Main page"},{"location":"basic-app/#routing","text":"Add a routing module. with ng g module features/routing . Define a route to home in a separate file (routes.ts) so it can be imported in test module. export const routes : Routes = [ { path : 'home' , component : HomeComponent }, { path : '**' , redirectTo : '/home' , pathMatch : 'full' } ]; * Add the routing definition in the routing module and export the RouterModule. import { routes } from './routes' ; @ NgModule ({ imports : [ RouterModule . forRoot ( routes , { useHash : true , enableTracing : false }), CommonModule ], exports : [ RouterModule ], }); Add the import RoutingModule in the main app Module import { RoutingModule } from './features/routing/routing.module' ; imports : [ BrowserModule , RoutingModule ],","title":"Routing"},{"location":"basic-app/#adding-footer-and-header","text":"Any shared component are in shared folder. Create a shared module: ng g module shared Create footer and header components: ng g component shared/header * Add those components in the export of the shared module @ NgModule ({ imports : [ CommonModule ], declarations : [ HeaderComponent , FooterComponent ], exports : [ FooterComponent , HeaderComponent ] }) Add the SharedModule in the imports of the app module. For each component we add basic jasmine tests on element presence within the component.","title":"Adding footer and header"},{"location":"basic-app/#map-with-leaflet","text":"See tutorial here Install it with npm --save install leaflet @types/leaflet Then modify angular.json file to add new styles: \"styles\": [ \"src/styles.css\", \"./node_modules/leaflet/dist/leaflet.css\" ], * Specify in the src/tsconfig.app.json to use the typescript version of the library Leaflet. \"compilerOptions\" : { \"outDir\" : \"../out-tsc/app\" , \"baseUrl\" : \"./\" , \"module\" : \"es2015\" , \"types\" : [ \"leaflet\" ] } , In the component to integrate the map add L variable with import * as L from 'leaflet' ;","title":"Map with Leaflet"},{"location":"dev-login/","text":"How to implement a login page The following requirements need to be supported: The application has a login page to get email and password then once authenticated the user is routed to a home page where he can access a set of business functions. The login mechanism needs a component and a service so we can package them as a module. So to prepare the code I use the following commands: ng g module features/login ng g component features/login ng g service features/login Start by tests of the login service To do continuous testing start ng test The first test to add is to get a User from a login operation given a user's email address as userid: it ( 'should get a user when calling login given username and password' , () => { const user : User = loginService . login ( \"eddie@email.com\" , \"pwd\" ); expect ( user . firstname ). toEqual ( 'Eddie' ); }); I use the Jasmine fit function to focus on this test to avoid running all the other tests while developing a new function. After tuning the import the test is failing as expected, so we need to add login method, User and then implement a simple login: login ( email : string , passwd : string ) : User { const userInfo : User = { email : email , password : passwd , firstname : 'test' , access_token : 'testToken' }; return userInfo ; } The second test is to verify the component for login and password form. We need to validate the user name as a mandatory field. The test in the login component looks like: it ( 'should have username as mandatory field' , () => { const userNameElement = fixture . debugElement . query ( By . css (( '#usernameInput' ))); // the requirement is not on the input as html element attribute but in validation rule const componentInstance = userNameElement . componentInstance ; expect ( componentInstance . validations [ 0 ]. type ). toEqual ( 'required' ); }); The test fails with \"Cannot read property 'componentInstance' of null\". So we need to create form and entry field in the login component. Follow the pattern introduced here We need now to verify the routing to the home page when user is logged in.","title":"Login page development"},{"location":"dev-login/#how-to-implement-a-login-page","text":"The following requirements need to be supported: The application has a login page to get email and password then once authenticated the user is routed to a home page where he can access a set of business functions. The login mechanism needs a component and a service so we can package them as a module. So to prepare the code I use the following commands: ng g module features/login ng g component features/login ng g service features/login","title":"How to implement a login page"},{"location":"dev-login/#start-by-tests-of-the-login-service","text":"To do continuous testing start ng test The first test to add is to get a User from a login operation given a user's email address as userid: it ( 'should get a user when calling login given username and password' , () => { const user : User = loginService . login ( \"eddie@email.com\" , \"pwd\" ); expect ( user . firstname ). toEqual ( 'Eddie' ); }); I use the Jasmine fit function to focus on this test to avoid running all the other tests while developing a new function. After tuning the import the test is failing as expected, so we need to add login method, User and then implement a simple login: login ( email : string , passwd : string ) : User { const userInfo : User = { email : email , password : passwd , firstname : 'test' , access_token : 'testToken' }; return userInfo ; } The second test is to verify the component for login and password form. We need to validate the user name as a mandatory field. The test in the login component looks like: it ( 'should have username as mandatory field' , () => { const userNameElement = fixture . debugElement . query ( By . css (( '#usernameInput' ))); // the requirement is not on the input as html element attribute but in validation rule const componentInstance = userNameElement . componentInstance ; expect ( componentInstance . validations [ 0 ]. type ). toEqual ( 'required' ); }); The test fails with \"Cannot read property 'componentInstance' of null\". So we need to create form and entry field in the login component. Follow the pattern introduced here We need now to verify the routing to the home page when user is logged in.","title":"Start by tests of the login service"}]}