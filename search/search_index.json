{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Angular 5 summary Must read https://angular.io/tutorial * Installation Module and declarations The purpose of a NgModule is to declare each thing you create in Angular, and groups them together. declarations is for things you\u2019ll use in your templates: mainly components. providers is for service declarations: declarations / components are in local scope (private visibility), providers / services are (generally) in global scope (public visibility) Components are only usable in the current module. If you need to use them outside the module, line in other modules, you\u2019ll have to export them. In the module below the components are declared and also exported as they are at the application global scope. declarations: [ InputComponent, DropdownComponent, MessageErrorComponent, FileUploadComponent ], providers: [ FileUploadService, ], exports: [ InputComponent, DropdownComponent, MessageErrorComponent, FileUploadComponent ] On the contrary, services you provided will generally be available / injectable anywhere in your app, in all modules. When assessing the import of module, you need to consider: if the module is imported for components, you\u2019ll need to import it in each module needing them, if the module is imported for services, you\u2019ll need to import it only once, in the first app module. Modules to import each time you need them: common module except in the first app module, because it\u2019s already part of the BrowserModule. FormsModule / ReactiveFormsModule MatXModule and other UI modules any other module giving you components, directives or pipes Modules to import only once HttpClientModule BrowserAnimationsModule or NoopAnimationsModule any other module providing you services only. Example of login module See the note here HttpClient https://medium.com/codingthesmartway-com-blog/angular-4-3-httpclient-accessing-rest-web-services-with-angular-2305b8fd654b Attribute binding When to use <element [attribute]=\"\" versus attribute2=\"\" https://stackoverflow.com/questions/39112904/property-binding-vs-attribute-interpolation","title":"Introduction"},{"location":"#angular-5-summary","text":"","title":"Angular 5 summary"},{"location":"#must-read","text":"https://angular.io/tutorial *","title":"Must read"},{"location":"#installation","text":"","title":"Installation"},{"location":"#module-and-declarations","text":"The purpose of a NgModule is to declare each thing you create in Angular, and groups them together. declarations is for things you\u2019ll use in your templates: mainly components. providers is for service declarations: declarations / components are in local scope (private visibility), providers / services are (generally) in global scope (public visibility) Components are only usable in the current module. If you need to use them outside the module, line in other modules, you\u2019ll have to export them. In the module below the components are declared and also exported as they are at the application global scope. declarations: [ InputComponent, DropdownComponent, MessageErrorComponent, FileUploadComponent ], providers: [ FileUploadService, ], exports: [ InputComponent, DropdownComponent, MessageErrorComponent, FileUploadComponent ] On the contrary, services you provided will generally be available / injectable anywhere in your app, in all modules. When assessing the import of module, you need to consider: if the module is imported for components, you\u2019ll need to import it in each module needing them, if the module is imported for services, you\u2019ll need to import it only once, in the first app module. Modules to import each time you need them: common module except in the first app module, because it\u2019s already part of the BrowserModule. FormsModule / ReactiveFormsModule MatXModule and other UI modules any other module giving you components, directives or pipes Modules to import only once HttpClientModule BrowserAnimationsModule or NoopAnimationsModule any other module providing you services only.","title":"Module and declarations"},{"location":"#example-of-login-module","text":"See the note here","title":"Example of login module"},{"location":"#httpclient","text":"https://medium.com/codingthesmartway-com-blog/angular-4-3-httpclient-accessing-rest-web-services-with-angular-2305b8fd654b","title":"HttpClient"},{"location":"#attribute-binding","text":"When to use <element [attribute]=\"\" versus attribute2=\"\" https://stackoverflow.com/questions/39112904/property-binding-vs-attribute-interpolation","title":"Attribute binding"},{"location":"angularcli/","text":"Angular CLI References https://www.sitepoint.com/ultimate-angular-cli-reference/","title":"Angular CLI"},{"location":"angularcli/#angular-cli","text":"","title":"Angular CLI"},{"location":"angularcli/#references","text":"https://www.sitepoint.com/ultimate-angular-cli-reference/","title":"References"},{"location":"basic-app/","text":"Basic Application Structure In this section I address the following subject: Main page Structure Routing footer and header Main page When creating the application with ng new command, the application is ready to run immediately with ng serve . But we want to add a home page, a login page, a standard header, footer and support internal routing, to do so we need to change the app.component.html to have just the page placeholders: < div class = \"container\" style = \"position:relative;\" > < router-outlet ></ router-outlet > </ div > We need to import the angular router in the app.module, but in fact it is better to isolate the main routing in its own module, and when a feature support page navigation it will define its own routes. We need to add a home component with ng g component features/home that we will enhance later. Routing Add a routing module. with ng g module features/routing . Define a route to home in a separate file (routes.ts) so it can be imported in test module. export const routes : Routes = [ { path : 'home' , component : HomeComponent }, { path : '**' , redirectTo : '/home' , pathMatch : 'full' } ]; * Add the routing definition in the routing module and export the RouterModule. import { routes } from './routes' ; @ NgModule ({ imports : [ RouterModule . forRoot ( routes , { useHash : true , enableTracing : false }), CommonModule ], exports : [ RouterModule ], }); Add the import RoutingModule in the main app Module import { RoutingModule } from './features/routing/routing.module' ; imports : [ BrowserModule , RoutingModule ], Adding footer and header Any shared component are in shared folder. Create a shared module: ng g module shared Create footer and header components: ng g component shared/header Add those components in the export of the shared module @ NgModule ({ imports : [ CommonModule ], declarations : [ HeaderComponent , FooterComponent ], exports : [ FooterComponent , HeaderComponent ] }) Add the SharedModule in the imports of the app module. For each component we add basic jasmine tests on element presence within the component. Map with Leaflet See tutorial here Install it with npm --save install leaflet @types/leaflet Then modify angular.json file to add new styles: \"styles\": [ \"src/styles.css\", \"./node_modules/leaflet/dist/leaflet.css\" ], Specify in the src/tsconfig.app.json to use the typescript version of the library Leaflet. \"compilerOptions\": { \"outDir\": \"../out-tsc/app\", \"baseUrl\": \"./\", \"module\": \"es2015\", \"types\": [\"leaflet\"] }, In the component to integrate the map add L variable with import * as L from 'leaflet' ;","title":"Basic App"},{"location":"basic-app/#basic-application-structure","text":"In this section I address the following subject: Main page Structure Routing footer and header","title":"Basic Application Structure"},{"location":"basic-app/#main-page","text":"When creating the application with ng new command, the application is ready to run immediately with ng serve . But we want to add a home page, a login page, a standard header, footer and support internal routing, to do so we need to change the app.component.html to have just the page placeholders: < div class = \"container\" style = \"position:relative;\" > < router-outlet ></ router-outlet > </ div > We need to import the angular router in the app.module, but in fact it is better to isolate the main routing in its own module, and when a feature support page navigation it will define its own routes. We need to add a home component with ng g component features/home that we will enhance later.","title":"Main page"},{"location":"basic-app/#routing","text":"Add a routing module. with ng g module features/routing . Define a route to home in a separate file (routes.ts) so it can be imported in test module. export const routes : Routes = [ { path : 'home' , component : HomeComponent }, { path : '**' , redirectTo : '/home' , pathMatch : 'full' } ]; * Add the routing definition in the routing module and export the RouterModule. import { routes } from './routes' ; @ NgModule ({ imports : [ RouterModule . forRoot ( routes , { useHash : true , enableTracing : false }), CommonModule ], exports : [ RouterModule ], }); Add the import RoutingModule in the main app Module import { RoutingModule } from './features/routing/routing.module' ; imports : [ BrowserModule , RoutingModule ],","title":"Routing"},{"location":"basic-app/#adding-footer-and-header","text":"Any shared component are in shared folder. Create a shared module: ng g module shared Create footer and header components: ng g component shared/header Add those components in the export of the shared module @ NgModule ({ imports : [ CommonModule ], declarations : [ HeaderComponent , FooterComponent ], exports : [ FooterComponent , HeaderComponent ] }) Add the SharedModule in the imports of the app module. For each component we add basic jasmine tests on element presence within the component.","title":"Adding footer and header"},{"location":"basic-app/#map-with-leaflet","text":"See tutorial here Install it with npm --save install leaflet @types/leaflet Then modify angular.json file to add new styles: \"styles\": [ \"src/styles.css\", \"./node_modules/leaflet/dist/leaflet.css\" ], Specify in the src/tsconfig.app.json to use the typescript version of the library Leaflet. \"compilerOptions\": { \"outDir\": \"../out-tsc/app\", \"baseUrl\": \"./\", \"module\": \"es2015\", \"types\": [\"leaflet\"] }, In the component to integrate the map add L variable with import * as L from 'leaflet' ;","title":"Map with Leaflet"},{"location":"dev-login/","text":"How to implement a login page The following requirements need to be supported: The application has a login page to get email and password then once authenticated the user is routed to a home page where he can access a set of business functions. The login mechanism needs a component and a service so we can package them as a module. So to prepare the code I use the following commands: ng g module features/login ng g component features/login ng g service features/login Start by tests of the login service To do continuous testing start ng test The first test to add is to get a User from a login operation given a user's email address as userid: it ( 'should get a user when calling login given username and password' , () => { const user : User = loginService . login ( \"eddie@email.com\" , \"pwd\" ); expect ( user . firstname ). toEqual ( 'Eddie' ); }); I use the Jasmine fit function to focus on this test to avoid running all the other tests while developing a new function. After tuning the import the test is failing as expected, so we need to add login method, User and then implement a simple login: login ( email : string , passwd : string ) : User { const userInfo : User = { email : email , password : passwd , firstname : 'test' , access_token : 'testToken' }; return userInfo ; } The second test is to verify the component for login and password form. We need to validate the user name as a mandatory field. The test in the login component looks like: it ( 'should have username as mandatory field' , () => { const userNameElement = fixture . debugElement . query ( By . css (( '#usernameInput' ))); // the requirement is not on the input as html element attribute but in validation rule const componentInstance = userNameElement . componentInstance ; expect ( componentInstance . validations [ 0 ]. type ). toEqual ( 'required' ); }); The test fails with \"Cannot read property 'componentInstance' of null\". So we need to create form and entry field in the login component. Follow the pattern introduced here We need now to verify the routing to the home page when user is logged in.","title":"How to implement a login page"},{"location":"dev-login/#how-to-implement-a-login-page","text":"The following requirements need to be supported: The application has a login page to get email and password then once authenticated the user is routed to a home page where he can access a set of business functions. The login mechanism needs a component and a service so we can package them as a module. So to prepare the code I use the following commands: ng g module features/login ng g component features/login ng g service features/login","title":"How to implement a login page"},{"location":"dev-login/#start-by-tests-of-the-login-service","text":"To do continuous testing start ng test The first test to add is to get a User from a login operation given a user's email address as userid: it ( 'should get a user when calling login given username and password' , () => { const user : User = loginService . login ( \"eddie@email.com\" , \"pwd\" ); expect ( user . firstname ). toEqual ( 'Eddie' ); }); I use the Jasmine fit function to focus on this test to avoid running all the other tests while developing a new function. After tuning the import the test is failing as expected, so we need to add login method, User and then implement a simple login: login ( email : string , passwd : string ) : User { const userInfo : User = { email : email , password : passwd , firstname : 'test' , access_token : 'testToken' }; return userInfo ; } The second test is to verify the component for login and password form. We need to validate the user name as a mandatory field. The test in the login component looks like: it ( 'should have username as mandatory field' , () => { const userNameElement = fixture . debugElement . query ( By . css (( '#usernameInput' ))); // the requirement is not on the input as html element attribute but in validation rule const componentInstance = userNameElement . componentInstance ; expect ( componentInstance . validations [ 0 ]. type ). toEqual ( 'required' ); }); The test fails with \"Cannot read property 'componentInstance' of null\". So we need to create form and entry field in the login component. Follow the pattern introduced here We need now to verify the routing to the home page when user is logged in.","title":"Start by tests of the login service"}]}